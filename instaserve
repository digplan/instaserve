#!/usr/bin/env node

import chalk from 'chalk'
import fs from 'node:fs'
import path from 'node:path'
import { pathToFileURL } from 'node:url'

console.log(chalk.cyan('\nInstaserve - Instant Web Stack\n'))
console.log(chalk.yellow('Usage:'))
console.log(chalk.green('  npx instaserve [options]'))
console.log(chalk.green('  npx instaserve generate-routes\n'))
console.log(chalk.yellow('Commands:'))
console.log(chalk.green('  generate-routes') + '   Create a sample routes.js file in the current directory\n')
console.log(chalk.yellow('Options:'))
console.log(chalk.green('  -port <number>') + '    Port to listen on (default: 3000)')
console.log(chalk.green('  -ip <address>') + '     IP address to bind to (default: 127.0.0.1)')
console.log(chalk.green('  -public <path>') + '    Public directory path (default: ./public)')
console.log(chalk.green('  -api <file>') + '       Path to routes file (default: ./routes.js)')
console.log(chalk.green('  -secure') + '           Enable HTTPS (requires cert.pem and key.pem: run generate-certs.sh)')
console.log(chalk.green('  -help') + '             Show this help message\n')

if (process.argv.includes('-help')) {
    process.exit(0)
}

const args = process.argv.slice(2)

// Handle generate-routes command
if (args[0] === 'generate-routes') {
    const routesFile = path.resolve(process.cwd(), './routes.js')
    if (fs.existsSync(routesFile)) {
        console.error(chalk.red(`Error: routes.js already exists`))
        process.exit(1)
    }
    
    const sampleRoutes = `export default {
    // Middleware functions (prefixed with _) run on every request
    // Return false to continue processing, or a value to use as response
    
    // Example: Log all requests
    _log: (req, res, data) => {
        console.log(\`\${req.method} \${req.url}\`)
        return false // Continue to next middleware or route
    },

    // Example: Basic authentication (commented out)
    // _auth: (req, res, data) => {
    //     if (!data.token) {
    //         res.writeHead(401)
    //         return 'Unauthorized'
    //     }
    //     return false // Continue if authorized
    // },

    // Regular route handlers
    hello: (req, res, data) => {
        return { message: 'Hello World' }
    },

    api: (req, res, data) => {
        return { message: 'API endpoint', data }
    },

    // Method-specific routes (POST, GET, PUT, DELETE)
    'POST /users': (req, res, data) => {
        return { message: 'Create user', data }
    },

    'GET /users': (req, res, data) => {
        return { message: 'Get users' }
    }
}
`
    
    fs.writeFileSync(routesFile, sampleRoutes)
    console.log(chalk.green(`âœ“ Created routes.js`))
    process.exit(0)
}

import server from './module.mjs'

const params = {}
for (let i = 0; i < args.length; i++) {
    const arg = args[i]
    if (arg.startsWith('-')) {
        const key = arg.slice(1)
        const nextArg = args[i + 1]
        if (nextArg && !nextArg.startsWith('-')) {
            params[key] = nextArg
            i++ // Skip the next argument since we used it
        } else {
            params[key] = true // Boolean flag
        }
    }
}

// Load routes file
let routes = {}
let routesFilePath = null
const routesFileParam = params.api || './routes.js'
const routesFileSpecified = !!params.api

// Resolve to absolute path from current working directory
const routesFile = path.isAbsolute(routesFileParam) 
    ? routesFileParam 
    : path.resolve(process.cwd(), routesFileParam)

if (routesFileSpecified && !fs.existsSync(routesFile)) {
    console.error(chalk.red(`Error: Routes file "${routesFileParam}" does not exist`))
    process.exit(1)
}

if (fs.existsSync(routesFile)) {
    try {
        const routesFileURL = pathToFileURL(routesFile).href
        const imported = await import(routesFileURL)
        routes = imported.default || imported
        
        if (!routes || typeof routes !== 'object' || Array.isArray(routes)) {
            console.error(chalk.red(`Error: Routes file "${routesFileParam}" must export a default object`))
            process.exit(1)
        }
        
        for (const [key, handler] of Object.entries(routes)) {
            if (typeof handler !== 'function') {
                console.error(chalk.red(`Error: Route "${key}" in "${routesFileParam}" must be a function`))
                process.exit(1)
            }
        }
        routesFilePath = routesFile
    } catch (e) {
        console.error(chalk.red(`Error: Could not load routes file "${routesFileParam}": ${e.message}`))
        process.exit(1)
    }
}

server(routes, params.port ? parseInt(params.port) : undefined, params.ip, routesFilePath) 